#! /usr/bin/env python
# -*- coding: utf-8 -*-

# Copyright (C) 2009 Ulteo SAS
# http://www.ulteo.com
# Author Gauvain POCENTEK <gauvain@ulteo.com>
# Author Julien LANGLOIS <julien@ulteo.com>
#
# This program is free software; you can redistribute it and/or 
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; version 2
# of the License
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

import os
import re
import subprocess
import sys

def append_to_file(pid, desktop):
    D = os.environ['OVD_SESSID_DIR']
    desktop = desktop.replace("\\", "\\\\")
    f = file(D+'/apps', 'a')
    f.write("%s %s\n"%(str(pid), desktop))
    f.close()

def del_from_file(pid):
    D = os.environ['OVD_SESSID_DIR']
    # windows pids will be strings (0x...)
    os.system('sed -i "/^%s /d" %s/apps'%(str(pid), D))

def getDestkopfileKey(filename_, key_):
    try:
        f = file(filename_, "r")
    except Exception:
        return None

    lines = f.readlines()
    f.close()
    for line in lines:
        if line.startswith(key_+"="):
            return line[len(key_)+1:].strip()

    return None

def getFinalCommand(cmd_, args_):
    if "%F" in cmd_:
        return cmd_.replace("%F", list2cmdline(args_))

    if "%U" in cmd_:
        b = []
        for arg in args_:
            if "://" not in arg:
                b.append('file://%s'%(os.path.abspath(arg)))
            else:
                b.append(arg)
        return cmd_.replace("%U", list2cmdline(b))

    # We add a non-standard message for Windows path translation
    if "%W" in cmd_:
        local_home = os.path.expanduser('~')
        b = []
        if os.environ.has_key("CIFS_HOME_DIR"):
            win_home = os.environ["CIFS_HOME_DIR"]
            for arg in args_:
                b.append("--start-app-arg")
                b.append(os.path.abspath(arg).replace(local_home, win_home))

        return cmd_.replace("%W", list2cmdline(b))

    cmd = cmd_
    args = args_
    args.reverse()

    while len(args)>0:
        i = cmd.find("%")
        try:
            tok = cmd[i+1]
        except Exception,e:
            tok = ""

        arg = args.pop()
        if tok == "u" and "://" not in arg:
            replace = "file://%s"%(os.path.abspath(arg))
        else:
            replace = arg

        cmd = cmd.replace("%"+tok, '"%s"'%(replace), 1)

    cmd = re.sub("%[a-z]", "", cmd)

    return cmd


# Hack for OOo instance on mutliple display
class Hack:    
    def __init__(self):
        self.appmode = (os.environ.has_key("NODESKTOP") and os.environ["NODESKTOP"] == "1")
        self.oooHack = False

    def changeCmdLine(self, cmd_line):
        if self.appmode and cmd_line.startswith("ooffice"):
            self.oooHack = True
            self.oooDir = ".ooo_%d"%(os.getpid())

            cmd_line+="-env:UserInstallation=%s"%(self.oooDir)

        return cmd_line

    def onExit(self):
        if self.oooHack:
            os.system("rm -rf %s"%(self.oooDir))

#
# the subprocess.list2cmdline function doesn't
# take care about the "(" or ")" characters ...
#
def list2cmdline(args):
    return " ".join('"'+arg+'"' for arg in args)


# stop if we don't have the needed env vars
if not os.environ.has_key('OVD_SESSID_DIR'):
    sys.exit(1)

# monitoring + application startup
if not len(sys.argv) > 2:
    sys.exit(1)

cmd = getDestkopfileKey(sys.argv[2], "Exec")
if cmd == None:
    sys.exit(2)

MYPID = os.getpid()

# notify application start
append_to_file(MYPID, sys.argv[1])

hack = Hack()

# run the appli
extra_args = sys.argv[3:]
if len(extra_args)==0 and os.environ.has_key("DOC"):
    extra_args = [os.environ["DOC"]]

cmd_line = getFinalCommand(cmd, extra_args)
cmd_line = hack.changeCmdLine(cmd_line)
os.system(cmd_line)
hack.onExit()

# notify end
del_from_file(MYPID)

sys.exit(0)
