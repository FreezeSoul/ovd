#!/bin/bash
# Copyright (C) 2006-2010 Ulteo SAS
# http://www.ulteo.com
# Author Gaël DUVAL <gduval@ulteo.com>
# Author Gauvain POCENTEK <gauvain@ulteo.com>
# Author Julien LANGLOIS <julien@ulteo.com>
# Author Jonathan LESTRELIN <jonathan@ulteo.com>
# Author Laurent CLOUET <laurent@ulteo.com>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License 
# as published by the Free Software Foundation, version 2
# of the License.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.


system_clean() {
    system_is_broken && return 1
    local fail=0

    for user in $(get_real_user); do
        log_INFO "system_clean: existing user '$user': deluser him"
        deluser $user
        if [ $? !=  0 ]; then
            log_ERROR "system_clean: unable to remove user '$user'"
            local fail=1
        fi
    done
    [ $fail = 0 ] || return $fail

    # Ensure no user homes are left:
    do_clean

    # Manage data removal and/or migration of a previous installation
    do_upgrade
}

do_upgrade() {
    rm -f /tmp/monitoring.xml
}

system_is_broken() {
    [ -f $SPOOL/broken ]
}

system_set_broken() {
    log_ERROR "Put the system in broken mode."
    touch $SPOOL/broken
    webservices_server_broken
    exit 1
}

check_cpulimit() {
    cache_ps_chroot_display | mawk '{ if ($3 > 25.0) print $1" "$2 }' |\
    while read i j; do
    if cache_is_cpulimited $j; then
        log_DEBUG "process $j already cpulimited"
    else
        k=$(id -u $i 2>/dev/null)

        if [ $? -eq 0 ] && [ $k -ge 1000 ]; then
            cpulimit -p $j -l 25 -z -q &
            log_INFO "limiting process $j"
        fi
    fi
    done
}

session_check_status() {
    SESSID=$1
    SESSID_DIR=$SPOOL/sessions/$SESSID
    i=$(cat $SESSID_DIR/private/id)

    VNC_USER="VNC$i"
    SSH_USER="SSH$i"

    if [ ! -d $SESSID_DIR ]; then
        log_ERROR "session_check_status: no such directory '$SESSID_DIR'"
        return 1
    fi

    if [ $# -gt 1 ]; then
        RUNASAP=$2
    else
        RUNASAP=$(cat ${SESSID_DIR}/infos/status)
    fi

    if ! session_valid_runasap $RUNASAP; then
        log_WARN "Unsupported runasap value for session $SESSID"
        session_switch_status $SESSID 3
        webservices_session_end_status $SESSID "internal1"
        session_check_status $SESSID 3
        return $?
    fi

    # if a session is required to stop asap
    if [ $RUNASAP -eq 3 ]; then
        log_INFO "Killing Session $SESSID"
        application_purge_all ${SESSID}
        session_purge ${SESSID}
        return 1
    fi

    # If sesion is not initialize yet
    if [ $RUNASAP -eq 0 ]; then 
        #
        # Clean active non-used session 
        # (runasap=0) since 3*CONNECTION_TIMEOUT seconds
        #
        local now=$(date +%s)
        local runasap=$(stat -c "%Z" ${SESSID_DIR}/infos/status)
        local diff=$(( $now - $runasap ))

        if [ $diff -gt $(( 3 * $CONNECTION_TIMEOUT )) ]; then
            log_WARN "garbage_collector: found non-used session '$SESSID' -> remove it"
            return 1
        fi

        return 0
    fi

    NICK=$(cat ${SESSID_DIR}/parameters/user_displayname)
    USER_LOGIN=$(cat ${SESSID_DIR}/parameters/user_login)

    SSH_SESSION=$(cache_ps_display | grep "sshd:" | grep "^$SSH_USER" | wc -l)
    log_DEBUG "Alive SSH tunelling connexion for $RFB_PORT: $SSH_SESSION"

    if [ -f $SESSID_DIR/parameters/persistent ]; then
        PERSISTENT=1
    else
        PERSISTENT=0
    fi

    # If sesion need to be restore ...
    if [ $RUNASAP -eq 11 ]; then 
        session_restore $SESSID
        [ $? -ne 0 ] && return 1
    fi

    # Check the timeout if the session is timetouted
    if [ -f ${SESSID_DIR}/private/running ] && [ -f ${SESSID_DIR}/parameters/timeout ]; then
        EXPIRE=$(cat ${SESSID_DIR}/parameters/timeout)

        local ct=$(date +%s)
        local diff=$(( $ct - $EXPIRE ))

        if [ ! -f ${SESSID_DIR}/private/timeouted  ] && [ $diff -gt -180 ]; then
            log_INFO "Session is going to expire in 3 minutes"
            export i SESSID_DIR SESSID
            timeout.sh &
            touch ${SESSID_DIR}/private/timeouted 
        fi

        if [ $diff -gt 0 ]; then
            log_INFO "Session expired => Timeout:$ct, EXPIRE:$EXPIRE, diff:$diff"
            session_switch_status $SESSID 3
            webservices_session_end_status $SESSID "timeout"
            session_check_status $SESSID 3
            return $?
        fi
    fi

    # If sesion is in suspend mode ... Nothing to do
    if [ $RUNASAP -eq 9 ] || [ $RUNASAP -eq 10 ]; then 
        return 0
    fi

    # if session owner has vanished, kill session (useful for shared sessions)
    KMA=${SESSID_DIR}/infos/keepmealive
    if [ -e $KMA ]; then
        local ctg2=$(date +%s)
        local candidate2=$(stat -c "%Z" $KMA)
        local diffg2=$(( $ctg2 - $candidate2 ))

        if [ $diffg2 -gt $CONNECTION_TIMEOUT ]; then
            log_WARN "KMA expired diff:$diffg2"
            # Suspend the session if the sesion was running and it's setup to suspend
            if [ -f ${SESSID_DIR}/private/running ] && [ -f ${SESSID_DIR}/parameters/persistent ]; then
                session_suspend $SESSID
                [ $? -eq 0 ] && return 0
            fi
            session_switch_status $SESSID 3
            webservices_session_end_status $SESSID "kma"
            session_check_status $SESSID 3
            return $?
        fi
    fi

    #
    # SWITCH CASE runasap
    #

    # session to launch? launch it! (runasap == 1)
    if [ $RUNASAP -eq 1 ]; then
        webservices_session_request $SESSID 1
        log_INFO "RUNASAP 1 for $SESSID..."

        if [ "$NICK" = "" ]; then
            log_ERROR "NULL nickname 2 "$NICK
            webservices_session_end_status $SESSID "internal2"
            return 1
        fi

        # If the user login is root or dbus or 
        # anything already exist, we change it
        session_change_login_if_needed || \
            USER_LOGIN=$(cat ${SESSID_DIR}/parameters/user_login)

        # If the home dir (based on displayname) exists we change it as well
        session_change_displayname_if_needed || \
            NICK=$(cat ${SESSID_DIR}/parameters/user_displayname)

        USER_HOME=/home/$NICK

        log_INFO "ulteo-ovd runasap1, nickname: '$NICK', USER_HOME:'$USER_HOME'"

        session_switch_status $SESSID 22
        RUNASAP=22

        set_user_env.sh $SESSID
        if [  $? -ne 0 ]; then
            session_switch_status $SESSID 3
            webservices_session_end_status $SESSID "internal2"
            session_check_status $SESSID 3
            return 1
        fi
        session_switch_status $SESSID 2

        local type=$(cat ${SESSID_DIR}/parameters/session_mode)
        if [ "$type" = "desktop" ]; then
            desktop.sh $SESSID &
            sleep 0.5
        else
            windows.sh $SESSID &
            sleep 0.5
        fi

        return 0

    elif [ $RUNASAP -eq 2 ]; then
        # if the owner_exit file exist, kill the session
        if [ -f ${SESSID_DIR}/infos/owner_exit ]; then
            local order=$(head -n 1 ${SESSID_DIR}/infos/owner_exit)
            local ret=$?
            log_INFO "Owner exit ($order)"

            # Suspend the session if the sesion was running and it's setup to suspend
            if [ -f ${SESSID_DIR}/private/running ] && [ -f ${SESSID_DIR}/parameters/persistent ] && [ $ret -eq 0 ] && [ "$order" == "suspend" ]; then
                session_suspend $SESSID
                if [ $? -ne 0 ]; then
                    session_switch_status $SESSID 3
                    webservices_session_end_status $SESSID "internal3"
                    session_check_status $SESSID 3
                    return $?
                fi
            else
                session_switch_status $SESSID 3
                webservices_session_end_status $SESSID "exit"
                session_check_status $SESSID 3
                return $?
            fi
        fi

        # if session without alive ssh connection 
        # and no luck, kill the whole session
        if [ $SSH_SESSION -eq 0 ] ;then
            if [ -f ${SESSID_DIR}/private/ssh_connected ]; then
                rm ${SESSID_DIR}/private/ssh_connected
                local timeout=1
            else
                local timeout=$CONNECTION_TIMEOUT
            fi

            local ready_t0=$(cat  ${SESSID_DIR}/private/ready_since)
            local ready_t1=$(date +%s)
            local diff=$(( $ready_t1 - $ready_t0 ))
            if [ $diff -gt $timeout ]; then
                log_ERROR "No ssh connection since $timeout seconds"
                # Suspend the session if the sesion was running and it's setup to suspend
                if [ -f ${SESSID_DIR}/private/running ] && [ -f ${SESSID_DIR}/parameters/persistent ]; then
                    session_suspend $SESSID
                    if [ $? -ne 0 ]; then
                        session_switch_status $SESSID 3
                        webservices_session_end_status $SESSID "internal3"
                        session_check_status $SESSID 3
                        return $?
                    fi
                else
                    session_switch_status $SESSID 3
                    if [ -f ${SESSID_DIR}/private/running ]; then
                        webservices_session_end_status $SESSID "exit"
                    else
                        webservices_session_end_status $SESSID "ssh"
                    fi
                    session_check_status $SESSID 3
                    return $?
                fi
            fi
        else
            if [ ! -f ${SESSID_DIR}/private/ssh_connected ]; then
                touch ${SESSID_DIR}/private/ssh_connected
                touch ${SESSID_DIR}/private/running
            fi
        fi

        application_loop $SESSID
    fi
}

session_process() {
    export PID=$(get_pid)
    export PNAME="pid $PID"
    log_INFO "session_process pid $PID"
    local my_sessions=""

    while [ 1 -eq 1 ]; do
        # first step: get new session if possible
        for SESSID in $(sessions_get_to_create); do
            local nb=$(find $SPOOL/sessions2create -name "$SESSID-lock-*" |wc -l)
            if [ $nb -ne 0 ]; then
                continue
            fi

            touch $SPOOL/sessions2create/$SESSID-lock-$PID
        
            local nb=$(find $SPOOL/sessions2create -name "$SESSID-lock-*" |wc -l)
            if [ $nb -ne 1 ] || [ ! -f $SPOOL/sessions2create/$SESSID ]; then
                rm $SPOOL/sessions2create/$SESSID-lock-$PID
                continue
            fi

            log_INFO "creating session $SESSID"

            session_init $SESSID
            local ret=$?

            rm $SPOOL/sessions2create/$SESSID
            rm $SPOOL/sessions2create/$SESSID-lock-$PID

	    if [ $ret -ne 0 ]; then
		log_ERROR "this session $SESSID will never continue :("
		break
	    fi

            local my_sessions="$my_sessions $SESSID"

            # Create only one session per loop
	    break;
	done

        # For each session we manage...
	for SESSID in $my_sessions; do
	    log_DEBUG "Session "$SESSID

	    session_check_status $SESSID
	    ret=$?

	    if [ $ret -eq 1 ]; then
                # we are not managing this session anymore
		local my_sessions=$(array_del "$my_sessions" $SESSID)
		session_remove $SESSID
	    fi
	done

	sleep 1s
    done
}



loop() {
    export PNAME="main"

    # check if the system is clean before to start
    system_clean
    if [ $? -ne 0 ]; then
        log_ERROR "Remaining garbage in home dirs, cannot start."
        webservices_server_broken
        exit 1
    fi

    spool_clean
    spool_init

    if [ ! -d /tmp/.X11-unix ]; then
            mkdir /tmp/.X11-unix
    fi
    chmod a+rwxt /tmp/.X11-unix

    if [ ! -d /tmp/.ICE-unix ]; then
        mkdir /tmp/.ICE-unix
    fi
    chmod a+rwxt /tmp/.ICE-unix

    # Give availables application to the sessionmanager
    # webservices_available_application || exit 1
    webservices_server_ready
    if [ $? -ne 0 ]; then
        log_ERROR "The request send to the Session manager to say hello returned an error, exiting"
        exit 1
    fi
    apt_daemon &
    PID_WATCH=$!

    cache_build

    PIDS_SESSION=""

    if [ -n "$NB_SUB_PROCESS" ]; then
        local nb=$NB_SUB_PROCESS
    else
        local nb=$(( $(get_ram) / 1024 / 1024  ))
        local nb=$(( ( $nb + $(get_nb_core) ) / 2 +1 ))
    fi
    log_INFO "Start $nb sessions spoolers"
    for i in $(seq $nb); do
        session_process "thread$i" &
        PIDS_SESSION="$PIDS_SESSION $!"
    done

    trap 'stop' KILL EXIT

    local t0=$(date +%s)
    while [ 1 ]; do
        cache_build

        local t1=$(date +%s)
        local diff=$(( $t1 - $t0 ))
        if [ $diff -gt 60 ]; then
            webservices_system_monitoring
            log_DEBUG "monitoring send result: $?"
            local t0=$(date +%s)
        fi

        local active=$(sessions_get_active)
        local tocreate=$(sessions_get_to_create)
        local nb_active=$(echo $active | wc -w)
        local nb_tocreate=$(echo $tocreate | wc -w)
        if [ $nb_active -gt 0 ] || [ $nb_tocreate -gt 0 ]; then
            log_DEBUG "loop active session: ${nb_active}, to create: ${nb_tocreate}"
        fi

        if [ -n "$USE_CPULIMIT" ] && [ $USE_CPULIMIT == "1" ]; then
            check_cpulimit
        fi

        sleep 1
    done
}

stop() {
    system_is_broken || webservices_server_down

    killall -q cpulimit

    [ $PID_WATCH ] && kill $PID_WATCH && wait $PID_WATCH

    for pid in $PIDS_SESSION; do
        kill $pid && wait $pid
    done

    for VNC in $(egrep ^VNC[0-9]+: /etc/passwd | cut -d ':' -f1); do
        for pid in $(ps -U $VNC | grep Xtightvnc | cut -d' ' -f 1); do
            kill $pid; kill -s 9 $pid
        done
    done
    killall -q startovd; killall -q -s 9 startovd

    for SESSID in $(sessions_get_active); do
        local SESSID_DIR=$SPOOL/sessions/$SESSID
        local RUNASAP=$(cat ${SESSID_DIR}/infos/status)
        if [ $RUNASAP -ne 0 ]; then
            webservices_session_end_status $SESSID "shutdown"
            session_purge $SESSID
        fi

        session_remove $SESSID
    done

    system_clean
    # if not 0 => broken !

    # Remove the old sessions from the local server
    spool_clean

    if [ -f "$PID_FILE" ]; then
       local mpid=$(cat $PID_FILE)
       if [ $mpid = $$ ]; then
           rm $PID_FILE
       fi
    fi

    exit 0
}

usage() {
    echo "$0 [-d|--daemonize] [-p|--pid filename]" >&2
    echo "    -d|--daemonize : detash from the main process" >&2
    echo "    -p|--pid filename : write the pid into 'filename'" >&2
}


# Define the default configuration
CONF_FILE=/etc/ulteo-ovd.conf
DAEMON=0

LOG_FILE=/var/log/ulteo-ovd.log
LOG_FLAGS="info warn error"
BIN_DIR=/usr/share/ulteo-ovd
SPOOL=/var/spool/ulteo-ovd
SPOOL_USERS=/var/spool/sessions
SESSION_MANAGER_URL="http://fire.ulteo.com/sessionmanager"
SERVERNAME=localhost
SERVER_HTTP_PORT=80
CONNECTION_TIMEOUT=100
USE_CPULIMIT=1
NB_SUB_PROCESS=
# end of default configuration

# turn off job control to avoid unwanted log messages
set +m

# unset some env vars
unset LANG
unset USERNAME

# If the admin restarts the daemon using sudo, its env is used, and
# if SESSION_MANAGER is set then xfce4-session will not want to start
unset SESSION_MANAGER

# Load/overwrite configution from config file
if [ ! -f $CONF_FILE ]; then
    echo "Missing configuration file '$CONF_FILE'" >&2
    exit 2
fi
. $CONF_FILE


# Load/overwrite configuration from command-line args
ARGS=$(getopt --unquoted -o dp: --long daemonize,no-daemonize,pid: -n $0 -- "$@")
if [ $? != 0 ]; then
    echo "Error usage" >&2
    usage
    exit 1
fi

eval set -- "$ARGS"
while true ; do
    case "$1" in
        -d|--daemonize)
            DAEMON=1
            shift;;
        -p|--pid)
            PID_FILE=$2
            shift 2;;
        --)
            shift;
            break ;;
        *)
            echo "Internal error!"
            exit 1;;
    esac
done


# Finally export the loaded configuration into env
export BIN_DIR SPOOL
export SPOOL_USERS
export LOG_FILE LOG_FLAGS
export SESSION_MANAGER_URL SERVERNAME
export SERVER_HTTP_PORT
export CONF_FILE
export CONNECTION_TIMEOUT
export NB_SUB_PROCESS

# Set PATH to BIN_DIR in priority
export PATH=$BIN_DIR:$PATH

if [ $DAEMON -eq 1 ]; then
    ARGS=$(echo $ARGS | sed -e "s/--daemonize//g" -e "s/-d//g")
    $0 $ARGS &
    exit 0
fi

if [ $PID_FILE ]; then
    PID=$$
    echo -n $PID >$PID_FILE
fi

. functions.sh
. log.sh
. modules_fs.sh

loop >>$LOG_FILE 2>&1
