#!/bin/bash 
# Copyright (C) 2006-2008 Ulteo SAS
# http://www.ulteo.com
# Author Gaël DUVAL <gduval@ulteo.com>
# Author Gauvain POCENTEK <gauvain@ulteo.com>
# Author Julien LANGLOIS <julien@ulteo.com>
# Author Jonathan LESTRELIN <jonathan@ulteo.com>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License 
# as published by the Free Software Foundation, version 2
# of the License.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.


system_clean() {
    system_is_broken && return 1
    local fail=0

    for user in $(get_real_user); do
        log_INFO "system_clean: existing user '$user': deluser him"
        deluser $user
        if [ $? !=  0 ]; then
            log_ERROR "system_clean: unable to remove user '$user'"
            local fail=1
        fi
    done
    [ $fail = 0 ] || return $fail

    # Last, to ensure no user homes are left :
    do_clean
}

system_is_broken() {
    [ -f $SPOOL/broken ]
}

system_set_broken() {
    log_ERROR "Put the system in broken mode."
    touch $SPOOL/broken
    webservices_server_broken
    exit 1
}

check_cpulimit() {
    cache_ps_chroot_display | mawk '{ if ($3 > 25.0) print $1" "$2 }' |\
    while read i j; do
    if cache_is_cpulimited $j; then
        log_DEBUG "process $j already cpulimited"
    else
        k=$(id -u $i 2>/dev/null)

        if [ $? -eq 0 ] && [ $k -ge 1000 ]; then
            cpulimit -p $j -l 25 -z&
            log_INFO "limiting process $j"
        fi
    fi
    done
}

session_check_status() {
    SESSID=$1
    SESSID_DIR=$SPOOL/sessions/$SESSID
    i=$(cat $SESSID_DIR/private/id)

    VNC_USER="VNC$i"
    SSH_USER="SSH$i"

    if [ ! -d $SESSID_DIR ]; then
        log_ERROR "session_check_status: no such directory '$SESSID_DIR'"
        return 1
    fi

    if [ $# -gt 1 ]; then
        RUNASAP=$2
    else
        RUNASAP=$(cat ${SESSID_DIR}/infos/status)
    fi

    if ! session_valid_runasap $RUNASAP; then
        log_WARN "Unsupported runasap value for session $SESSID"
        session_switch_status $SESSID 3
        session_check_status $SESSID 3
        return $?
    fi

    # if a session is required to stop asap
    if [ $RUNASAP -eq 3 ]; then
        log_INFO "Killing Session $SESSID"
        session_purge ${SESSID}
        return 1
    fi

    # If sesion is not initialize yet
    if [ $RUNASAP -eq 0 ]; then 
        return 0
    fi

    NICK=$(cat ${SESSID_DIR}/parameters/user_displayname)
    USER_LOGIN=$(cat ${SESSID_DIR}/parameters/user_login)

    SSH_SESSION=$(cache_ps_display | grep "sshd:" | grep "^$SSH_USER" | wc -l)
    log_DEBUG "Alive SSH tunelling connexion for $RFB_PORT: $SSH_SESSION"

    if [ -f $SESSID_DIR/parameters/persistent ]; then
        PERSISTENT=1
    else
        PERSISTENT=0
    fi

    # If sesion need to be restore ...
    if [ $RUNASAP -eq 11 ]; then 
        session_restore $SESSID
        [ $? -ne 0 ] && return 1
    fi

    # Check the timeout if the session is timetouted
    if [ -f ${SESSID_DIR}/private/running ] && [ -f ${SESSID_DIR}/parameters/timeout ]; then
        EXPIRE=$(cat ${SESSID_DIR}/parameters/timeout)

        local ct=$(date +%s)
        local diff=$(( $ct - $EXPIRE ))

        if [ ! -f ${SESSID_DIR}/private/timeouted  ] && [ $diff -gt -180 ]; then
            log_INFO "Session is going to expire in 3 minutes"
            export i SESSID_DIR SESSID
            timeout.sh &
            touch ${SESSID_DIR}/private/timeouted 
        fi

        if [ $diff -gt 0 ]; then
            log_INFO "Session expired => Timeout:$ct, EXPIRE:$EXPIRE, diff:$diff"
            session_switch_status $SESSID 3
            session_check_status $SESSID 3
            return $?
        fi
    fi

    # If sesion is in suspend mode ... Nothing to do
    if [ $RUNASAP -eq 9 ] || [ $RUNASAP -eq 10 ]; then 
        return 0
    fi

    # if session owner has vanished, kill session (useful for shared sessions)
    KMA=${SESSID_DIR}/infos/keepmealive
    if [ -e $KMA ]; then
        local ctg2=$(date +%s)
        local candidate2=$(stat -c "%Z" $KMA)
        local diffg2=$(( $ctg2 - $candidate2 ))

        if [ $diffg2 -gt 20 ]; then
            log_WARN "KMA expired diff:$diffg2"
            # Suspend the session if the sesion was running and it's setup to suspend
            if [ -f ${SESSID_DIR}/private/running ] && [ -f ${SESSID_DIR}/parameters/persistent ]; then
                session_suspend $SESSID
                [ $? -eq 0 ] && return 0
            fi
            session_switch_status $SESSID 3
            session_check_status $SESSID 3
            return $?
        fi
    fi

    #
    # SWITCH CASE runasap
    #

    # session to launch? launch it! (runasap == 1)
    if [ $RUNASAP -eq 1 ]; then
        webservices_session_request $SESSID 1
        log_INFO "RUNASAP 1 for $SESSID..."

        if [ "$NICK" = "" ]; then
            log_ERROR "NULL nickname 2 "$NICK
            return 1
        fi

        # If the user login is root or dbus or 
        # anything already exist, we change it
        session_change_login_if_needed || \
            USER_LOGIN=$(cat ${SESSID_DIR}/parameters/user_login)


        USER_HOME=/home/$NICK
        echo $NICK > /tmp/VNC$i

        log_INFO "ulteo-ovd runasap1, nickname: '$NICK', USER_HOME:'$USER_HOME'"

        session_switch_status $SESSID 22
        RUNASAP=22

        set_user_env.sh $SESSID
        if [  $? -ne 0 ]; then
            session_switch_status $SESSID 3
            session_check_status $SESSID 3
            return 1
        fi
        session_switch_status $SESSID 2

        local type=$(cat ${SESSID_DIR}/parameters/session_mode)
        if [ "$type" == "desktop" ]; then
            desktop.sh $SESSID &
            sleep 0.5
        fi

        return 0

    elif [ $RUNASAP -eq 2 ]; then
        # if the owner_exit file exist, kill the session
        if [ -f ${SESSID_DIR}/infos/owner_exit ]; then
            log_INFO "Owner exit"
            # Suspend the session if the sesion was running and it's setup to suspend
            if [ -f ${SESSID_DIR}/private/running ] && [ -f ${SESSID_DIR}/parameters/persistent ]; then
                session_suspend $SESSID
                if [ $? -ne 0 ]; then
                    session_switch_status $SESSID 3
                    session_check_status $SESSID 3
                    return $?
                fi
            else
                session_switch_status $SESSID 3
                session_check_status $SESSID 3
                return $?
            fi
        fi

        # if session without alive ssh connection 
        # and no luck, kill the whole session
        if [ $SSH_SESSION -eq 0 ] ;then
            if [ -f ${SESSID_DIR}/private/ssh_connected ]; then
                rm ${SESSID_DIR}/private/ssh_connected
                local timeout=1
            else
                local timeout=$CONNECTION_TIMEOUT
            fi

            local ready_t0=$(cat  ${SESSID_DIR}/private/ready_since)
            local ready_t1=$(date +%s)
            local diff=$(( $ready_t1 - $ready_t0 ))
            if [ $diff -gt $timeout ]; then
                log_ERROR "No ssh connection since $timeout seconds"
                session_switch_status $SESSID 3
                session_check_status $SESSID 3
                return $?
            fi
        else
            if [ ! -f ${SESSID_DIR}/private/ssh_connected ]; then
                touch ${SESSID_DIR}/private/ssh_connected
                touch ${SESSID_DIR}/private/running
            fi
        fi

        application_loop $SESSID
    fi
}

## Garbage Collector
# clean possibly remaining user dirs, only if they are umounted
#
garbage_collector() {
    #
    # Clean active session non-used 
    # (runasap=0) since 60 second
    #
    for SESSID in $(sessions_get_active); do
        local SESSID_DIR=$SPOOL/sessions/$SESSID
        local RUNASAP=$(cat ${SESSID_DIR}/infos/status)
        [ $RUNASAP -ne 0 ] && continue

        local now=$(date +%s)
        local runasap=$(stat -c "%Z" ${SESSID_DIR}/infos/status)
        local diff=$(( $now - $runasap ))

        if [ $diff -gt 60 ]; then
            log_WARN "garbage_collector: found non-used session '$SESSID' -> remove it"
            session_remove $SESSID
        fi
    done
}

loop() {
    # check if the system is clean before to start
    system_clean
    if [ $? -ne 0 ]; then
        log_ERROR "Remaining garbage in home dirs, cannot start."
        webservices_server_broken
        exit 1
    fi

    trap 'stop' KILL EXIT
    spool_clean
    spool_init

    if [ ! -d /tmp/.X11-unix ]; then
            mkdir /tmp/.X11-unix
    fi
    chmod a+rwxt /tmp/.X11-unix

    if [ ! -d /tmp/.ICE-unix ]; then
        mkdir /tmp/.ICE-unix
    fi
    chmod a+rwxt /tmp/.ICE-unix

    # Give availables application to the sessionmanager
    # webservices_available_application || exit 1
    webservices_server_ready
    if [ $? -ne 0 ]; then
        log_ERROR "The request send to the Session manager to say hello returned an error, exiting"
        exit 1
    fi
    apt_daemon &
    PID_WATCH=$!

    local t0=$(date +%s)
    while [ 1 ]; do
        cache_build

        local t1=$(date +%s)
        local diff=$(( $t1 - $t0 ))
        if [ $diff -gt 60 ]; then
            webservices_system_monitoring
            log_DEBUG "monitoring send result: $?"
            local t0=$(date +%s)
        fi

        local active=$(sessions_get_active)
        local tocreate=$(sessions_get_to_create)
        local nb_active=$(echo $active | wc -w)
        local nb_tocreate=$(echo $tocreate | wc -w)
        if [ $nb_active -gt 0 ] || [ $nb_tocreate -gt 0 ]; then
            log_DEBUG "loop active session: ${nb_active}, to create: ${nb_tocreate}"
        fi

        check_cpulimit

        # Check session to create
        for SESSID in $(sessions_get_to_create); do
            log_INFO "creating session $SESSID"
            session_init $SESSID
            rm $SPOOL/sessions2create/$SESSID
        done

        # For each session ...
        for SESSID in $(sessions_get_active); do
            log_DEBUG "Ses "$SESSID
            session_check_status $SESSID
            ret=$?

            [ $ret -eq 1 ] && session_remove $SESSID
        done

        garbage_collector
        sleep 1
    done
}

stop() {
    system_is_broken || webservices_server_down

    [ $PID_WATCH ] && kill $PID_WATCH && wait $PID_WATCH
    killall -q Xtightvnc
    killall -q gam_server
    killall -q startovd

    killall -q -s 9 Xtightvnc
    killall -q -s 9 gam_server
    killall -q -s 9 startovd
    killall -q -s 9 kblankscrn.kss

    for SESSID in $(sessions_get_active); do
        local SESSID_DIR=$SPOOL/sessions/$SESSID
        local RUNASAP=$(cat ${SESSID_DIR}/infos/status)
        if [ $RUNASAP -ne 0 ]; then
            session_purge $SESSID
        fi

        session_remove $SESSID
    done

    system_clean
    # if not 0 => broken !

    # Remove the old sessions from the local server
    spool_clean

    if [ -f "$PID_FILE" ]; then
       local mpid=$(cat $PID_FILE)
       if [ $mpid == $$ ]; then
           rm $PID_FILE
       fi
    fi

    exit 0
}

usage() {
    echo "$0 [-d|--daemonize] [-p|--pid filename]" >&2
    echo "    -d|--daemonize : detash from the main process" >&2
    echo "    -p|--pid filename : write the pid into 'filename'" >&2
}


# Define the default configuration
CONF_FILE=/etc/ulteo-ovd.conf
DAEMON=0

LOG_FILE=/var/log/ulteo-ovd.log
LOG_FLAGS="info warn error"
BIN_DIR=/usr/share/ulteo-ovd
SPOOL=/var/spool/ulteo-ovd
SPOOL_USERS=/var/spool/sessions
SESSION_MANAGER_URL="http://fire.ulteo.com/sessionmanager"
SERVERNAME=localhost
CONNECTION_TIMEOUT=20
# end of default configuration

# unset some env vars
unset LANG
unset USERNAME

# If the admin restarts the daemon using sudo, its env is used, and
# if SESSION_MANAGER is set then xfce4-session will not want to start
unset SESSION_MANAGER

# Load/overwrite configution from config file
if [ ! -f $CONF_FILE ]; then
    echo "Missing configuration file '$CONF_FILE'" >&2
    exit 2
fi
. $CONF_FILE


# Load/overwrite configuration from command-line args
ARGS=$(getopt --unquoted -o dp: --long daemonize,no-daemonize,pid: -n $0 -- "$@")
if [ $? != 0 ]; then 
    echo "Error usage" >&2
    usage
    exit 1
fi

eval set -- "$ARGS"
while true ; do
    case "$1" in
        -d|--daemonize)
            DAEMON=1
            shift;;
        -p|--pid)
            PID_FILE=$2
            shift 2;;
        --)
            shift;
            break ;;
        *)
            echo "Internal error!" 
            exit 1;;
    esac
done


# Finally export the loaded configuration into env
export BIN_DIR SPOOL
export SPOOL_USERS
export LOG_FILE LOG_FLAGS
export SESSION_MANAGER_URL SERVERNAME
export CONF_FILE
export CONNECTION_TIMEOUT

# Set PATH to BIN_DIR in priority
export PATH=$BIN_DIR:$PATH

if [ $DAEMON -eq 1 ]; then
    ARGS=$(echo $ARGS | sed -e "s/--daemonize//g" -e "s/-d//g")
    $0 $ARGS &
    exit 0
fi

if [ $PID_FILE ]; then
    PID=$$
    echo -n $PID >$PID_FILE
fi

. functions.sh
. log.sh
. modules_fs.sh

loop >>$LOG_FILE 2>&1
