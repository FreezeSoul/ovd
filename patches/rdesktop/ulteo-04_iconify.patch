=== modified file 'proto.h'
--- old/proto.h	2009-10-07 09:51:23 +0000
+++ new/proto.h	2009-10-07 09:53:09 +0000
@@ -312,6 +312,7 @@
 unsigned int seamless_send_focus(unsigned long id, unsigned long flags);
 unsigned int seamless_send_spawn(char *cmdline);
 unsigned int seamless_send_destroy(unsigned long id);
+unsigned int seamless_send_kill(unsigned long id);
 /* scard.c */
 void scard_lock(int lock);
 void scard_unlock(int lock);

=== modified file 'rdesktop.c'
--- old/rdesktop.c	2009-10-07 09:51:23 +0000
+++ new/rdesktop.c	2009-10-07 09:53:09 +0000
@@ -50,6 +50,10 @@
 
 #include "ssl.h"
 
+enum icon{
+	NONE = 0, ICONIFY, UNICONIFY
+};
+
 char g_title[64] = "";
 char g_username[64];
 char g_hostname[16];
@@ -95,6 +99,8 @@
 RD_BOOL g_ownbackstore = True;	/* We can't rely on external BackingStore */
 RD_BOOL g_seamless_rdp = False;
 enum main_frame g_main_frame = MAIN_FRAME_NORMAL;
+enum icon g_icon = NONE;
+RD_BOOL g_destroy_by_display = False;
 
 /* Master socket identifier */
 char *master_socket = NULL;
@@ -449,6 +455,9 @@
 		{"main-frame", 1, NULL, 10},
 		{"start-app", 1, NULL, 11},
 		{"start-app-arg", 1, NULL, 12},
+		{"iconify-by-display", 1, NULL, 13},
+		{"uniconify-by-display", 1, NULL, 14},
+		{"destroy-by-display", 1, NULL, 15},
 		{NULL, 0, NULL, 0} /* End of array need by getopt_long do not delete it*/
 	};
 #ifdef WITH_RDPSND
@@ -522,6 +531,21 @@
 				}
 				break;
 
+			case 13: //--iconify-by-display
+				g_icon = ICONIFY;
+				arg = optarg;
+				break;
+
+			case 14: //--uniconify-by-display
+				g_icon = UNICONIFY;
+				arg = optarg;
+				break;
+
+			case 15: //--destroy-by-display
+				g_destroy_by_display = True;
+				arg = optarg;
+				break;
+
 			case 'A':
 				g_seamless_rdp = True;
 				break;
@@ -889,6 +913,21 @@
 			error("You connot use --start-app and -l at the same time\n");
 			return 1;
 		}
+		if(g_icon == ICONIFY)
+		{
+			error("You cannot use --start-app and --iconify-by-display at the same time\n");
+			return 1;
+		}
+		if(g_icon == UNICONIFY)
+		{
+			error("You cannot use --start-app and --uniconify-by-display at the same time\n");
+			return 1;
+		}
+		if(g_destroy_by_display)
+		{
+			error("You cannot use --start-app and --destroy-by-display at the same time\n");
+			return 1;
+		}
 
 		startup_id = getenv("DESKTOP_STARTUP_ID");
 
@@ -911,6 +950,46 @@
 		return 0;
 	}
 
+	if (g_icon != NONE)
+	{
+		char buf[4096];
+
+		if(g_destroy_by_display)
+		{
+			error("You cannot use --(un)iconify-by-display and --destroy-by-display at the same time\n");
+			return 1;
+		}
+
+		switch(g_icon)
+		{
+			case ICONIFY:
+				snprintf (buf, sizeof(buf), "ICON|ON|%s", arg);
+				break;
+			case UNICONIFY:
+				snprintf (buf, sizeof(buf), "ICON|OFF|%s", arg);
+				break;
+			default:
+				break;
+		}
+
+		seamless_socket_send(master_socket, buf);
+		return 0;
+	}
+
+	if(g_destroy_by_display)
+	{
+		char buf[4096];
+
+		snprintf (buf, sizeof(buf), "DESTROY|%s|%d", arg, (int)getpid());
+
+		seamless_socket_send(master_socket, buf);
+
+		while(1)
+			sleep(10);
+
+		return 0;
+	}
+
 	if (argc - optind != 1)
 	{
 		usage(argv[0]);

=== modified file 'seamless.c'
--- old/seamless.c	2009-10-07 09:51:23 +0000
+++ new/seamless.c	2009-10-07 09:55:12 +0000
@@ -588,6 +588,13 @@
 		return seamless_send("START_APP", "0x%08lx,%s \"%s\"", token, cmdline, arg);
 }
 
+/* Send client-to-server message to kill process on the server. */
+unsigned int
+seamless_send_kill(unsigned long id)
+{
+	return seamless_send("KILL", "0x%08lx", id);
+}
+
 /* Check seamless master mode socket and send spawn command if input found.
  * Returns 0 if a slave connected and sent command, 1 otherwise.  */
 int
@@ -726,6 +733,44 @@
 
 		return 0;
 	}
+	else if(str_startswith(mm, "ICON"))
+	{
+		char *icon;
+
+			mm = strtok(mm, "|");
+		icon = strtok(NULL, "|");
+		displayName = strtok(NULL, "|");
+		if(strcmp(icon, "ON") == 0)
+		{
+			if(xdisplay_all_windows_iconify(displayName))
+				return 0;
+		}
+		else if(strcmp(icon, "OFF") == 0)
+		{
+			if(xdisplay_all_windows_uniconify(displayName))
+				return 0;
+		}
+		error("Bad command or display in socket file\n");
+		return 1;
+	}
+	else if(str_startswith(mm, "DESTROY"))
+	{
+		int pid;
+		int success = 0;
+
+		mm = strtok(mm, "|");
+		displayName = strtok(NULL, "|");
+		pid = atoi(strtok(NULL, "|"));
+
+		if(!xdisplay_all_windows_kill(displayName))
+		{
+			success = 1;
+			error("Bad command or display in socket file\n");
+		}
+		kill((pid_t)pid, SIGTERM);
+
+		return success;
+	}
 
 	snprintf(cmdline, 256, mm);
 

=== modified file 'xdisplay.c'
--- old/xdisplay.c	2009-10-07 09:51:23 +0000
+++ new/xdisplay.c	2009-10-07 09:58:04 +0000
@@ -46,6 +46,7 @@
 
 extern unsigned char g_pointer_log_to_phys_map[32];
 extern RD_BOOL g_numlock_sync;
+extern xwindow* xwindow_first;
 
 xdisplay* xdisplay_g_first = NULL;
 
@@ -73,6 +74,32 @@
 	dis->next = xdisplay_g_first;
 	xdisplay_g_first = dis;
 	DEBUG(("Display %s added\n", dis->name));
+	printf("Display %s added\n", dis->name);
+}
+
+void
+xdisplay_remove(xdisplay *dis)
+{
+	xdisplay *obj, *prev = NULL;
+
+	for (obj = xdisplay_g_first; obj; obj = obj->next)
+	{
+		if (obj == dis)
+		{
+			if (prev != NULL)
+				prev->next = obj->next;
+			else
+				xdisplay_g_first = obj->next;
+
+			obj->next = NULL;
+
+			xfree(obj);
+
+			return;
+		}
+
+		prev = obj;
+	}
 }
 
 RD_BOOL
@@ -223,6 +250,27 @@
 	return dis;
 }
 
+void
+xdisplay_destroy(xdisplay *dis)
+{
+	int i;
+
+	if(dis->display)
+	{
+		for(i = 0; i < 0x20; i++)
+		{
+			if(dis->xcursorcache[i] != NULL)
+				XFreeCursor(dis->display, (Cursor)dis->xcursorcache[i]);
+		}
+		XCloseDisplay(dis->display);
+
+		DEBUG(("Display %s removed\n", dis->name));
+	}
+	xfree(dis->name);
+
+	xdisplay_remove(dis);
+}
+
 xdisplay*
 xdisplay_find(char *name)
 {
@@ -1025,3 +1073,74 @@
 		warning("Broken Window Manager: Timeout while waiting for ConfigureNotify\n");
 	}
 }
+
+RD_BOOL
+xdisplay_all_windows_iconify(char *disName)
+{
+	xdisplay *dis;
+	xwindow *sw;
+
+	dis = xdisplay_find(disName);
+
+	if(dis == NULL)
+		return False;
+
+	for(sw = xwindow_first; sw != NULL; sw = sw->next)
+	{
+		if(sw->sa->dis == dis)
+		{
+			XIconifyWindow(dis->display, sw->wnd, DefaultScreen(dis->display));
+			sw->state = xdisplay_ewmh_get_window_state(dis, sw->wnd);
+			seamless_send_state(sw->id, sw->state, 0);
+		}
+	}
+	return True;
+}
+
+RD_BOOL
+xdisplay_all_windows_uniconify(char *disName)
+{
+	xdisplay *dis;
+	xwindow *sw;
+
+	dis = xdisplay_find(disName);
+
+	if(dis == NULL)
+		return False;
+
+	for(sw = xwindow_first; sw != NULL; sw = sw->next)
+	{
+		if(sw->sa->dis == dis)
+		{
+			XMapWindow(dis->display, sw->wnd);
+			sw->state = xdisplay_ewmh_get_window_state(dis, sw->wnd);
+			seamless_send_state(sw->id, sw->state, 0);
+		}
+	}
+	return True;
+}
+
+RD_BOOL
+xdisplay_all_windows_kill(char *disName)
+{
+	xdisplay *dis;
+	xwindow *sw, *next = NULL;
+
+	dis = xdisplay_find(disName);
+
+	if(dis == NULL)
+		return False;
+
+	for(sw = xwindow_first; sw != NULL; sw = next)
+	{
+		next = sw->next;
+		if(sw->sa->dis == dis)
+		{
+			seamless_send_kill(sw->sa->windows_pid);
+			xwindow_destroy(sw);
+		}
+	}
+	xdisplay_destroy(dis);
+
+	return True;
+}

=== modified file 'xdisplay.h'
--- old/xdisplay.h	2009-10-07 09:51:23 +0000
+++ new/xdisplay.h	2009-10-07 09:59:12 +0000
@@ -75,6 +75,9 @@
 void xdisplay_seamless_ack(unsigned int serial);
 void xdisplay_seamless_syncbegin(unsigned long flags);
 void xdisplay_group_destroy(unsigned long id, unsigned long flags);
+RD_BOOL xdisplay_all_windows_iconify(char *disName);
+RD_BOOL xdisplay_all_windows_uniconify(char *disName);
+RD_BOOL xdisplay_all_windows_kill(char *disName);
 
 void xdisplay_get_input_mask(long *input_mask);
 void xdisplay_get_window_attribs(xdisplay* dis, XSetWindowAttributes * attribs);

=== modified file 'xwindow.c'
--- old/xwindow.c	2009-10-07 09:51:23 +0000
+++ new/xwindow.c	2009-10-07 09:53:09 +0000
@@ -26,7 +26,7 @@
 
 extern RD_BOOL g_seamless_broken_restack;
 
-static xwindow* xwindow_first = NULL;
+xwindow* xwindow_first = NULL;
 
 static void xwindow_add(xwindow *);
 static void xwindow_remove(xwindow * win);

