=== modified file 'rdesktop.c'
--- old/rdesktop.c	2009-09-28 08:07:15 +0000
+++ new/rdesktop.c	2009-10-06 13:14:29 +0000
@@ -99,6 +99,7 @@
 char *master_socket = NULL;
 /* Seamless slave mode flag */
 RD_BOOL seamless_slave = False;
+RD_BOOL seamless_start_app = False;
 
 uint32 g_embed_wnd;
 uint32 g_rdp5_performanceflags =
@@ -440,9 +441,13 @@
 	RD_BOOL geometry_option = False;
 	int run_count = 0;	/* Session Directory support */
 	RD_BOOL continue_connect = True;	/* Session Directory support */
+	char *arg = NULL;
+	char *arg2 = NULL;
 	static const struct option long_options[]=
 	{
 		{"main-frame", 1, NULL, 10},
+		{"start-app", 1, NULL, 11},
+		{"start-app-arg", 1, NULL, 12},
 		{NULL, 0, NULL, 0} /* End of array need by getopt_long do not delete it*/
 	};
 #ifdef WITH_RDPSND
@@ -501,6 +506,21 @@
 					usage(argv[0]);
 				break;
 
+			case 11: //--start-app
+				seamless_start_app = True;
+				arg = strdup(optarg);
+				break;
+
+			case 12: //--start-app-arg
+				if (seamless_start_app)
+					arg2 = strdup(optarg);
+				else
+				{
+					fprintf(stderr, "--start-app-arg cannot be used without --start-app\n");
+					return 1;
+				}
+				break;
+
 			case 'A':
 				g_seamless_rdp = True;
 				break;
@@ -857,7 +877,39 @@
 
 		sprintf(master_socket, "%s/.rdesktop/seamless.socket", home);
 	}
-	
+
+	if (seamless_start_app)
+	{
+		char buf[4096];
+		char *startup_id;
+
+		if (seamless_slave)
+		{
+			error("You connot use --start-app and -l at the same time\n");
+			return 1;
+		}
+
+		startup_id = getenv("DESKTOP_STARTUP_ID");
+
+		if (startup_id && startup_id != '\0')
+			startup_id = strdup(startup_id);
+		else
+			startup_id = strdup("");
+
+		unsetenv("DESKTOP_STARTUP_ID");
+
+		snprintf (buf, sizeof(buf), "STARTAPP|%s|%s|%d|%s\n", arg, (arg2)?arg2:" ", (int)getpid(), startup_id);
+
+		seamless_socket_send(master_socket, buf);
+
+		xfree(startup_id);
+
+		while(1)
+			sleep(60);
+
+		return 0;
+	}
+
 	if (argc - optind != 1)
 	{
 		usage(argv[0]);

=== modified file 'seamless.c'
--- old/seamless.c	2009-09-25 11:54:40 +0000
+++ new/seamless.c	2009-10-06 13:14:29 +0000
@@ -26,6 +26,8 @@
 #include <sys/stat.h>
 #include <sys/socket.h>
 #include <sys/un.h>
+#include <time.h>
+#include <signal.h>
 #include <unistd.h>
 #include "seamless.h"
 
@@ -360,6 +362,24 @@
 
 		ui_seamless_unhide_desktop();
 	}
+	else if (!strcmp("APP_ID", tok1))
+	{
+		unsigned int token;
+		unsigned int pid;
+
+		if (!tok4)
+			return False;
+
+		token = strtoul(tok3, &endptr, 0);
+		if (*endptr)
+			return False;
+
+		pid = strtoul(tok4, &endptr, 0);
+		if (*endptr)
+			return False;
+
+		seamless_register_pid(token, pid);
+	}
 
 
 	xfree(l);
@@ -536,6 +556,36 @@
 	return seamless_send("SPAWN", cmdline);
 }
 
+unsigned int
+seamless_send_start_app(char *cmdline, char *arg, unsigned int pid, char *startup_id)
+{
+	int token = (int)time(NULL);
+	seamless_application * sa = NULL;
+
+	if (!g_seamless_rdp)
+		return (unsigned int) -1;
+
+	// Create a new Seamless App and register it
+	sa = xmalloc(sizeof(seamless_application));
+	memset(sa, 0, sizeof(seamless_application));
+	sa->cmdline = strdup(cmdline);
+	sa->arg = strdup(arg);
+	sa->rdesktop_pid = pid;
+	if(strcmp(startup_id, "") == 0)
+		sa->startup_id = NULL;
+	else
+		sa->startup_id = startup_id;
+	sa->token = token;
+	sa->next = NULL;
+
+	seamless_application_add(sa);
+
+	if (arg == NULL || strlen(arg) == 0 || (strlen(arg) == 1 && arg[0] == ' '))
+		return seamless_send("START_APP", "0x%08lx,%s", token, cmdline);
+	else
+		return seamless_send("START_APP", "0x%08lx,%s \"%s\"", token, cmdline, arg);
+}
+
 /* Check seamless master mode socket and send spawn command if input found.
  * Returns 0 if a slave connected and sent command, 1 otherwise.  */
 int
@@ -545,10 +595,12 @@
 	struct timeval tv;
 	int slaves, index, ns;
 	struct sockaddr_un fsaun;
-	char cmdline[256];
+	char cmdline[260]; //windows's MAX_PATH = 260
 	socklen_t fromlen;
 	FILE *fp;
-	char c;
+	char buffer[1024];
+	char *hh;
+	char *mm;
 
 	FD_ZERO(&rfds);
 	FD_SET(sock, &rfds);
@@ -581,14 +633,77 @@
 
 	/* Read command from client socket */
 	fp = fdopen(ns, "r");
-	index = 0;
-	while ((c = fgetc(fp)) != EOF && index < 256)
+
+	index = fread(buffer, sizeof(char), 1024, fp);
+	if (index >0)
+		buffer[index] = '\0';
+
+	hh = strdup(buffer);
+	if (hh == NULL)
+		return 0;
+
+	mm = strtok(buffer, "\n");
+	if (mm == NULL) {
+		free(hh);
+		hh = NULL;
+		return 0;
+	}
+
+	if (str_startswith(mm, "STARTAPP"))
 	{
-		cmdline[index] = c;
-
-		index++;
+		unsigned int pid;
+		char arg[256];
+		char startup_id[1024];
+
+		startup_id[0] = '\0';
+
+		mm = strtok(mm, "|");
+		mm = strtok(NULL, "|");
+		if (mm == NULL) {
+			free(hh);
+			hh = NULL;
+			return 0;
+		}
+		snprintf(cmdline, sizeof(cmdline), mm);
+
+		mm = strtok(NULL, "|");
+		if (mm == NULL) {
+			free(hh);
+			hh = NULL;
+			return 0;
+		}
+		snprintf(arg, sizeof(arg), mm);
+
+		mm = strtok(NULL, "|");
+		if (mm == NULL) {
+			free(hh);
+			hh = NULL;
+			return 0;
+		}
+		pid = atoi(mm);
+
+		mm = strtok(NULL, "\n");
+		if(mm != NULL)
+		{
+			snprintf(startup_id, sizeof(startup_id), mm);
+		}
+		puts("4");
+		free(hh);
+		hh = NULL;
+
+		DEBUG(("STARTAPP cmdline: %s arg: '%s' pid: %d startup_id: %s\n", cmdline, arg, pid, startup_id));
+
+		seamless_send_start_app(cmdline, arg, pid, startup_id);
+
+		return 0;
 	}
-	cmdline[index] = '\0';
+
+	snprintf(cmdline, 256, mm);
+
+	free(hh);
+	hh = NULL;
+
+	DEBUG(("cmdline: %ss\n", cmdline));
 
 	/* Send spawn command to server-side SeamlessRDP component */
 	seamless_send_spawn(cmdline);
@@ -673,3 +788,97 @@
 
 	return 0;
 }
+
+
+static seamless_application *g_seamless_application = NULL;
+
+void seamless_register_pid(unsigned int token, unsigned int pid) {
+        seamless_application * obj = seamless_application_get_by_token(token);
+        printf("Register %d on %d\n", token, pid);
+
+        if (!obj) {
+                printf("Error, don't find any seamless_application token %d\n", token);
+                return;
+        }
+
+        if(pid == -1)
+        {
+        	seamless_application_remove(obj);
+
+        	return;
+        }
+        obj->windows_pid = pid;
+}
+
+seamless_application *
+seamless_application_get_by_token(unsigned int token)
+{
+	seamless_application *obj;
+	for (obj = g_seamless_application; obj; obj = obj->next)
+	{
+		if (obj->token == token)
+			return obj;
+	}
+	return NULL;
+}
+
+seamless_application *
+seamless_application_get_by_pid(unsigned int pid)
+{
+	seamless_application *obj;
+	for (obj = g_seamless_application; obj; obj = obj->next)
+	{
+		if (obj->windows_pid == pid)
+			return obj;
+	}
+	return NULL;
+}
+
+void
+seamless_application_add(seamless_application * target)
+{
+        target->next = g_seamless_application;
+        g_seamless_application = target;
+}
+
+void
+seamless_application_remove(seamless_application * target)
+{
+	seamless_application *obj, *prev = NULL;
+
+	for (obj = g_seamless_application; obj; obj = obj->next)
+	{
+		if (obj == target)
+		{
+			if(kill((pid_t)obj->rdesktop_pid, SIGTERM) != 0)
+			{
+				error("rdesktop startapp process (%d) cannot be killed.\n", obj->rdesktop_pid);
+			}
+
+			if (prev != NULL)
+				prev->next = obj->next;
+			else
+				g_seamless_application = obj->next;
+
+			obj->next = NULL;
+
+			xfree(obj->cmdline);
+			xfree(obj->arg);
+			xfree(obj->startup_id);
+
+			xfree(obj);
+			return;
+		}
+
+		prev = obj;
+	}
+}
+
+void
+seamless_application_remove_all()
+{
+	seamless_application *sa;
+
+	for(sa = g_seamless_application; sa != NULL; sa = sa->next)
+		seamless_application_remove(sa);
+}

=== modified file 'seamless.h'
--- old/seamless.h	2009-09-25 11:54:40 +0000
+++ new/seamless.h	2009-10-06 13:14:29 +0000
@@ -26,3 +26,25 @@
 void seamless_close_socket(char *socket_name);
 /* Send a command line to seamless master socket. */
 int seamless_socket_send(char *socket_name, char *cmdline);
+
+
+// Seamless Application management
+typedef struct _seamless_app
+{
+	char * cmdline;
+	char * arg;
+	char * startup_id;
+	unsigned int token;
+	unsigned int windows_pid;
+	unsigned int rdesktop_pid;
+
+	struct _seamless_app *next;
+} seamless_application;
+
+seamless_application * seamless_application_get_by_token(unsigned int token);
+seamless_application * seamless_application_get_by_pid(unsigned int pid);
+void seamless_application_add(seamless_application * target);
+void seamless_application_remove(seamless_application * target);
+void seamless_application_remove_all();
+
+void seamless_register_pid(unsigned int token, unsigned int pid);

=== modified file 'xwin.c'
--- old/xwin.c	2009-09-28 08:07:15 +0000
+++ new/xwin.c	2009-10-06 13:14:29 +0000
@@ -63,6 +63,8 @@
 typedef struct _seamless_window
 {
 	Window wnd;
+	seamless_application* sa;
+
 	unsigned long id;
 	unsigned long behind;
 	seamless_group *group;
@@ -1947,6 +1949,8 @@
 		sw_remove_window(g_seamless_windows);
 	}
 
+	seamless_application_remove_all();
+
 	xclip_deinit();
 
 	if (g_IM != NULL)
@@ -3690,6 +3694,73 @@
 	g_seamless_active = !g_seamless_active;
 }
 
+static void
+ui_end_startup_notify(char *startup_id)
+{
+	unsigned int len_startup_id;
+	unsigned int i;
+	char buf[1024];
+	char msg[2048];
+	char *p;
+	XSetWindowAttributes attrs;
+	Window root_wnd;
+	Window wnd;
+	Atom type_atom;
+	Atom type_atom_begin;
+	XEvent xevent;
+	const char* msg_end;
+
+	/* escape for xmessage */
+	p = buf;
+	len_startup_id = strlen(startup_id);
+
+	for(i = 0; i < len_startup_id; i++)
+	{
+		if(startup_id[i] == ' ' || startup_id[i] == '"' || startup_id[i] == '\\')
+		{
+			*p++ = '\\';
+		}
+		*p++ = startup_id[i];
+	}
+	*p = '\0';
+
+	/* format xmessage */
+	snprintf(msg, sizeof(msg), "remove: ID=%s", buf);
+
+	/* broadcast xmessage */
+	root_wnd = DefaultRootWindow(g_display);
+
+	attrs.override_redirect = True;
+	attrs.event_mask = PropertyChangeMask | StructureNotifyMask;
+	wnd = XCreateWindow(g_display, root_wnd, -100, -100, 1, 1, 0, CopyFromParent, CopyFromParent, CopyFromParent, CWOverrideRedirect | CWEventMask, &attrs);
+
+	type_atom = XInternAtom(g_display, "_NET_STARTUP_INFO", False);
+	type_atom_begin = XInternAtom(g_display, "_NET_STARTUP_INFO_BEGIN", False);
+
+	xevent.xclient.type = ClientMessage;
+	xevent.xclient.message_type = type_atom_begin;
+	xevent.xclient.display = g_display;
+	xevent.xclient.window = wnd;
+	xevent.xclient.format = 8;
+
+	p = msg;
+	msg_end = p + sizeof(msg) + 1; // Include trailing NUL.
+
+	while (p != msg_end) {
+		char* dest = &xevent.xclient.data.b[0];
+		char* dest_end = dest + 20;
+		while (dest != dest_end && p != msg_end) {
+			*dest++ = *p++;
+		}
+		while (dest != dest_end) {
+			*dest++ = 0;
+		}
+		XSendEvent(g_display, root_wnd, False, PropertyChangeMask, &xevent);
+		xevent.xclient.message_type = type_atom;
+	}
+
+	XDestroyWindow(g_display, wnd);
+}
 
 void
 ui_seamless_create_window(unsigned long id, unsigned long group, unsigned long parent,
@@ -3702,6 +3773,7 @@
 	XWMHints *wmhints;
 	long input_mask;
 	seamless_window *sw, *sw_parent;
+	seamless_application *sa;        
 
 	if (!g_seamless_active)
 		return;
@@ -3710,6 +3782,13 @@
 	sw = sw_get_window_by_id(id);
 	if (sw)
 		return;
+        
+	sa = seamless_application_get_by_pid(group);
+	if (! sa)
+		printf("Warning CREATE windows not associate to seamless_application\n");
+	else {
+		printf("CREATE window for application %s\n", sa->cmdline);
+	}
 
 	get_window_attribs(&attribs);
 	wnd = XCreateWindow(g_display, RootWindowOfScreen(g_screen), -1, -1, 1, 1, 0, g_depth,
@@ -3787,6 +3866,7 @@
 	memset(sw, 0, sizeof(seamless_window));
 
 	sw->wnd = wnd;
+	sw->sa = sa;
 	sw->id = id;
 	sw->group = sw_find_group(group, False);
 	sw->group->refcnt++;
@@ -3812,6 +3892,12 @@
 		XSetWMHints(g_display, sw->wnd, wmhints);
 		XFree(wmhints);
 	}
+
+	if(sa && sa->startup_id)
+	{
+		ui_end_startup_notify(sa->startup_id);
+		sa->startup_id = NULL;
+	}
 }
 
 
@@ -3839,6 +3925,7 @@
 ui_seamless_destroy_group(unsigned long id, unsigned long flags)
 {
 	seamless_window *sw, *sw_next;
+	seamless_application *sa;
 
 	if (!g_seamless_active)
 		return;
@@ -3853,6 +3940,9 @@
 			sw_remove_window(sw);
 		}
 	}
+
+	if((sa = seamless_application_get_by_pid(id)) && sa != NULL)
+		seamless_application_remove(sa);
 }
 
 

